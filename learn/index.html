<!DOCTYPE html>

<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Document</title>
	</head>

	<style>
		body,
		html {
			margin: 0;
			height: 100%;
		}

		.box {
			/* transform: translate(10px, 20px); */
			background-color: rgb(86, 168, 255);
			height: 100%;
			/* width: 20px;
      height: 20px; */
		}
	</style>

	<body>
		<div>
			<button>111</button>
		</div>

		<input type="text" onchange="stopShake(1000)" />

		<button onmouseUp="btnClickHandler(event)">CLICK ME</button>

		<button onclick="myClick(1000)">CLICK ME</button>

		<div class="box"></div>
	</body>

	<!-- 事件冒泡 -->
	<!-- <script>
        const btn = document.getElementsByTagName('button')[0]
        const div = document.getElementsByTagName('div')[0]
        btn.addEventListener('click', (e) => {
            console.log(e.target);
            e.stopImmediatePropagation()
            e.stopPropagation()
        })
        div.addEventListener('click', (e) => {
            console.log(e.target);
        })
        div.addEventListener('mouseup', (e) => {
            console.log(e.target);
        })

        document.addEventListener("mouseup", function (event) {
            console.log("document clicked");
        }, false);
    
        function btnClickHandler(event) {
            // event.stopPropagation(); 
            console.log("btn clicked");
        }

    </script> -->

	<!-- Object对象 -->
	<!-- <script>
      const o0 = new Object('宛攀');
      const o1 = new Object(111);
      console.log(o0, o1);

      const o2 = Object.prototype.toString.call('string');
      console.log(o2);
    </script> -->

	<!-- async await -->
	<!-- <script>
      /* 直接返回形式 */
      async function test_1(params) {
        /* reject */
        throw 1;
        /* resolve */
        // return params;
      }

      async function test(params) {
        // 赋值
        // const num = (await test_1(params)) + 2;

        // 链式
        await test_1(params)
          .then((feed) => {
            // console.log('#1', feed);
          })
          .catch((e) => {
            // console.log(e);
          });

        // console.log('#2', num);
      }

      /* 返回Promise 形式 */
      // async function test_1(params) {
      //   return new Promise((rev) => {
      //     setTimeout(() => {
      //       rev(params);
      //     }, 200);
      //   });
      // }

      // async function test(params) {
      //   // 赋值
      //   const num = (await test_1(params)) + 2;

      //   // 链式
      //   await test_1(params).then((feed) => {
      //     console.log('#1', feed);
      //   });

      //   console.log('#2', num);
      // }

      test(6);

      /* 
            Generator 函数
            Generator对象 像是一个方法集合 每个yield域 就是集合中的一个方法（子集们 被嵌套在一个公共方法里 所以每个子集都可以访问到其它子集的变量）
            每次调用next 方法就是执行下一个 yield域里的方法
        */
      //   function* mengmeng() {
      //     let a = yield 0;
      //     let b = yield a;
      //     yield b;
      //   }

      // const fun = mengmeng(1);
      // console.log(fun.next())
      // console.log(fun.next(1))
      // console.log(fun.next(2))

      //   const getRawType = (target) =>
      //     Object.prototype.toString.call(target).slice(8, -1);

      //   const __createArrayIterable = (arr) => {
      //     if (typeof Symbol !== 'function' || !Symbol.iterator) return {};
      //     if (getRawType(arr) !== 'Array') throw new Error('it must be Array');
      //     const iterable = {};
      //     iterable[Symbol.iterator] = () => {
      //       arr.length++;
      //       const iterator = {
      //         next: () => ({ value: arr.shift(), done: arr.length <= 0 }),
      //       };
      //       return iterator;
      //     };
      //     return iterable;
      //   };

      //   const itable = __createArrayIterable(['人月', '神话']);
      //   const it = itable[Symbol.iterator]();

      //   console.log(it.next()); // { value: "人月", done: false }
      //   console.log(it.next()); // { value: "神话", done: false }
      //   console.log(it.next()); // {value: undefined, done: true }
    </script> -->

	<!-- promise 原理 -->
	<!-- <script>
      const wanpan = new Promise((rev, rej) => {
        setTimeout(() => {
          if (Math.random() * 10 > 5) {
            rev(1);
          } else {
            rej(0);

            // 需要相应的catch 才能捕捉reject
            // Promise.reject(0).catch((err) => {
            //   debugger;
            //   console.log(err);
            // });
          }
        }, 1000);
      });

      wanpan
        .then((res) => {
          console.log(res);
        })
        .catch((err) => {
          console.log(err);
        });

      // setInterval(() => {
      //   console.log(wanpan);
      // }, 50);
    </script> -->

	<!-- JSON -->
	<!-- <script>
      // const obj = {
      //   wanpan: '11',
      // };
      // const str = encodeURIComponent(JSON.stringify(obj));
      // console.log('str-1', str);
      // console.log('str-2', decodeURIComponent(str));
      // console.log('str-3', JSON.parse(decodeURIComponent(str)));

      const str = encodeURIComponent(
        `taskId:1111-materialId:2222-H5Id:3333-originId:4444`,
      );

      const getStateParams = (strState) => {
        const obj = {};
        strState.split('-').forEach((el) => {
          const arr = el.split(':');
          obj[arr[0]] = arr[1];
        });
        return obj;
      };
      console.log(getStateParams(decodeURIComponent(str)));
    </script> -->

	<!-- this -->
	<!-- <script>
      var wanpan = 'c';
      var obj = {
        wanpan: 'b',
        getNmae: () => {
          return this.wanpan;
        },
      };

      console.log(obj.getNmae());
    </script> -->

	<!-- 闭包问题 -->
	<!-- <script>
    let obj = { name: 'wanpan' };

    function test() {
      console.log(obj.name);
    }

    setTimeout(test, 3000);
    obj.name = 111;
  </script> -->

	<!-- new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。 -->
	<!-- <script>
    // 函数表达式
    const wanpan = function () {
      console.log('函数表达式');
    };

    // 函数声明 具有变量提示
    function wanpan() {
      console.log('函数声明');
    }

    // 方法定义 方法没有构造函数
    const obj = {
      wanpan() {
        console.log('方法定义');
      },
    };

    ----- ES5 新写法 
    const obj_1 = {
      method() { // 但是这种新写法没有构造函数
        return 'Hello!';
      },
    };

    // 等同于 
    const obj_1 = {
      method: function (name) {
        this.name = name;
        return 'Hello!';
      },
    };

  ----- ES5 新写法 

    //例4 只有当类型为Normal的函数被创建时，它才是可构造的函数，否则他就是不可构造的。
    const example = {
      Fn: function () {
        console.log(this);
      }, // 函数 Normal
      Arrow: () => {
        console.log(this);
      }, // 箭头函数 Arrow
      Shorthand() {
        console.log(this);
      }, // 方法 Method
    };
    new example.Fn(); // Fn {}
    new example.Arrow(); // Uncaught TypeError: example.Arrow is not a constructor
    new example.Shorthand(); // Uncaught TypeError: example.Shorthand is not a constructor
  </script> -->
	<!-- 手写new -->
	<!-- <script>
    /* 接受一个构建函数 若干个参数 返回实例（或） */
    const my_new = function (constructor, ...args) {
      // 1、定义一个新对象
      const obj = {};

      // 2、获取构造函数的返回值
      const res = constructor.call(obj, ...args);

      // 3、将新对象的__proto__指向构造函数的prototype
      obj.__proto__ = constructor.prototype;

      // 4、判断构造函数的返回值 是否为对象 如果是则返此对象，反之返回新对象（实例）
      return res instanceof Object ? res : obj;
    };

    function Wanpan(name) {
      this.name = name;
      this.say = function () {
        console.log(this.name);
      };
      // return {};
    }

    // console.log(Wanpan.prototype);

    const wanpan = my_new(Wanpan, '宛攀');
    wanpan.say();
  </script> -->

	<!-- Symbol -->
	<!-- <script>
    window.onerror = (e) => {
      console.log('onerror', e);
    };

    const a = Symbol('foo');
    console.log(a);
    console.log(String(a));

    const obj = { name: 'wanpan' };

    obj.age.name;
  </script> -->

	<!-- 消息订阅 -->
	<!-- <script>
    // 发布订阅对象
    const eventEmitter = {};

    // 缓存列表，存放 event 及 fn
    eventEmitter.list = {};

    /* 订阅消息 */
    eventEmitter.on = function (event, fn) {
      const that = this;

      /* 如果订阅列表中 没有该事件就创建该事件并添加订阅回调 反之直接push新的回调函数*/
      if (!that.list[event]) {
        that.list[event] = [];
      }
      that.list[event].push(fn);

      return that;
    };

    /* 发布消息 */
    eventEmitter.emit = function () {
      const that = this;

      /* 获取事件名称 */
      const event = [].shift.call(arguments);
      /* 获取事件内 回调函数 */
      const fns = [...this.list[event]];

      if (!fns || fns.length < 1) {
        return false;
      } else {
        fns.forEach((fn) => {
          fn.call(that, arguments);
        });
      }
    };

    function user1(content) {
      console.log('用户1订阅了:', content);
    }

    function user2(content) {
      console.log('用户2订阅了:', content);
    }

    // 订阅
    eventEmitter.on('article', user1);
    eventEmitter.on('article', user2);

    // 发布
    eventEmitter.emit('article', 'Javascript 发布-订阅模式');

    console.log(eventEmitter);

    /*
    用户1订阅了: Javascript 发布-订阅模式
    用户2订阅了: Javascript 发布-订阅模式
    */
  </script> -->

	<!-- 防抖 -->
	<script>
		const stopShakeFun = (sceond = 200) => {
			let timer = null; // 定时器

			// 返回依赖timer 的闭包函数
			return (fun, params) => {
				// timer存在说明触发过 这里清理下
				if (timer) {
					clearTimeout(timer);
				}

				// 清理完 再次赋值新的定时器
				timer = setTimeout(() => {
					fun(...params);
					// console.log(arguments);
				}, sceond);
			};
		};

		const myClick = stopShakeFun(500);
	</script>

	<!-- 链表 -->
	<!-- <script>
		//创建链表
		function CreateLinkNode(data, pre, next) {
			this.data = data;
			this.preNode = pre;
			if (this.preNode) {
				pre.nextNode = this;
			}
			this.nextNode = next;
		}

		CreateLinkNode.prototype.print = function () {
			if (this.nextNode) {
				return this.data.name + this.nextNode.print();
			} else {
				return this.data.name;
			}
		};

		// 在当前调用节点右边 插入新节点
		CreateLinkNode.prototype.insertNode = function (node) {
			// 如果当前节点不是最后一个节点
			if (this.nextNode && this.nextNode.preNode) {
				this.nextNode.preNode = node;
			}

			node.nextNode = this.nextNode;

			node.preNode = this;
			this.nextNode = node;
		};

		//删除某一个节点
		CreateLinkNode.prototype.removeNode = function () {
			this.nextNode.preNode = this.preNode;
			this.preNode.nextNode = this.nextNode;
		};

		//反序链表
		CreateLinkNode.prototype.revertNode = function () {
			var tmp = null; //{nextNode: null, preNode: null};
			function revert() {
				if (!this.nextNode) {
					this.preNode = null;
					this.nextNode = tmp;
					return this;
				} else {
					this.preNode = this.nextNode;
					this.nextNode = tmp;
					tmp = this;
					return revert.call(this.preNode);
				}
			}

			return revert.call(this);

			1;
		};

		var ln1 = new CreateLinkNode({ name: "1" }, null, null);
		var ln2 = new CreateLinkNode({ name: "2" }, ln1, null);
		var ln3 = new CreateLinkNode({ name: "3" }, ln2, null);
		var ln4 = new CreateLinkNode({ name: "4" }, ln3, null);
		var ln5 = new CreateLinkNode({ name: "5" }, null, null);

		var lHead = ln1;

		console.log(ln1);

		ln4.insertNode(ln5);

		console.log(lHead.print()); //12345

		ln3.removeNode();
		console.log(lHead.print()); // 1245
		ln2.insertNode(ln3);
		console.log(lHead.print()); // 12345
		lHead = lHead.revertNode();
		console.log(lHead.print()); // 54321
	</script> -->

	<!--  -->

	<script src="./main.js" type="module"></script>
</html>
