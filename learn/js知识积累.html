<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>

  <style>
    body,
    html {
      margin: 0;
      height: 100%;
    }
    .box {
      /* transform: translate(10px, 20px); */
      background-color: rgb(86, 168, 255);
      height: 100%;
      /* width: 20px;
      height: 20px; */
    }
  </style>

  <body>
    <!-- <div>
      <button>111</button>
    </div> -->

    <div class="box"></div>

    <!-- <button onmouseUp="btnClickHandler(event)">CLICK ME</button> -->
  </body>

  <!-- 类 原型链  -->
  <!-- <script type="text/javascript">
      // 1.创建一个类
      class Wanp {
        // 构造器方法
        constructor(a, b) {
          this.name = a;
          this.age = b;
        }

        // 实例方法 仅实例化对象才能访问
        say() {
          return '我是Wanpan的实例方法say';
        }
        size = '我是Wanp的实例属性！';

        // 静态方法 static 会生成私有属性 实例化对象无法访问
        static staticFuc() {
          return '我是Wanp的静态方法！';
        }
        static staticStr = '我是Wanp的静态属性！';
      }
      // console.log('#1-1 Wanp -', Wanp.prototype);
      // console.log('#1-2 Wanp.staticStr -', Wanp.staticStr);
      // console.log('#1-3 Wanp.staticFuc -', Wanp.staticFuc());

      const wanpan = new Wanp('宛攀', 25);
      // console.log('#2-1 wanpan -', wanpan);
      // console.log('#2-2 wanpan.say -', wanpan.say());
      // console.log('#2-3 wanpan.size -', wanpan.size);

      // 实例无法访问原型对象的静态方法
      // console.log('#3-4 wanpan.staticStr -', wanpan.staticStr);
      // console.log('#2-5 wanpan.staticFuc() -', wanpan.staticFuc());

      // 1.1类的继承
      class Wanpan1 extends Wanp {
        constructor(a, b, c) {
          //当前类如果继承与其他类 且需要构造器时 需要使用super()先调用父级构造器方法
          super(a, b);
          this.sex = c;
        }
      }
      const wanpan1 = new Wanpan1('宛攀', 25, '男');
      // console.log('#3-1 wanpan.staticFuc() -', wanpan1);

      /* =============================================================================== */

      // 1.创建一个类(函数)
      function Tanxiufen(a, b) {
        //这里实际返回的 init的实例对象
        return new Tanxiufen.prototype.init(a, b);
      }

      Tanxiufen.prototype = {
        constructor: Tanxiufen,
        init: function (a, b) {
          this.name = a;
          this.age = b;
        },
        say: function () {
          return console.log(this.name + '今年' + this.age);
        },
        age: '888',
      };

      //因为 new Tanxiufen() 时间返回的是init的实例 所有需要把init的prototype 修改为Tanxiufen的prototype 从而拥有say()方法
      Tanxiufen.prototype.init.prototype = Tanxiufen.prototype;
      const tanxiufen = new Tanxiufen('谈秀芬', 24);

      console.log(Tanxiufen.prototype);
      console.log(tanxiufen.__proto__);
    </script> -->
  <!-- <script>
        function Person() {
            this.name;
        }
        Person.prototype.say = function () {
            console.log("hello");
        }

        var person = new Person();

        console.log(Person.__proto__);
        console.log(Function.prototype);

        console.log(Person.prototype.__proto__);
        console.log(Object.prototype);

        console.log(person.__proto__);
        console.log(Person.prototype);

        console.log(Person.prototype.constructor);
        console.log(Person);
    </script> -->

  <!-- 事件冒泡 -->
  <!-- <script>
        const btn = document.getElementsByTagName('button')[0]
        const div = document.getElementsByTagName('div')[0]
        btn.addEventListener('click', (e) => {
            console.log(e.target);
            e.stopImmediatePropagation()
            e.stopPropagation()
        })
        div.addEventListener('click', (e) => {
            console.log(e.target);
        })
        div.addEventListener('mouseup', (e) => {
            console.log(e.target);
        })

        document.addEventListener("mouseup", function (event) {
            console.log("document clicked");
        }, false);
    
        function btnClickHandler(event) {
            // event.stopPropagation(); 
            console.log("btn clicked");
        }

    </script> -->

  <!-- Object对象 -->
  <!-- <script>
      const o0 = new Object('宛攀');
      const o1 = new Object(111);
      console.log(o0, o1);

      const o2 = Object.prototype.toString.call('string');
      console.log(o2);
    </script> -->

  <!-- async await -->
  <!-- <script>
      /* 直接返回形式 */
      async function test_1(params) {
        /* reject */
        throw 1;
        /* resolve */
        // return params;
      }

      async function test(params) {
        // 赋值
        // const num = (await test_1(params)) + 2;

        // 链式
        await test_1(params)
          .then((feed) => {
            // console.log('#1', feed);
          })
          .catch((e) => {
            // console.log(e);
          });

        // console.log('#2', num);
      }

      /* 返回Promise 形式 */
      // async function test_1(params) {
      //   return new Promise((rev) => {
      //     setTimeout(() => {
      //       rev(params);
      //     }, 200);
      //   });
      // }

      // async function test(params) {
      //   // 赋值
      //   const num = (await test_1(params)) + 2;

      //   // 链式
      //   await test_1(params).then((feed) => {
      //     console.log('#1', feed);
      //   });

      //   console.log('#2', num);
      // }

      test(6);

      /* 
            Generator 函数
            Generator对象 像是一个方法集合 每个yield域 就是集合中的一个方法（子集们 被嵌套在一个公共方法里 所以每个子集都可以访问到其它子集的变量）
            每次调用next 方法就是执行下一个 yield域里的方法
        */
      //   function* mengmeng() {
      //     let a = yield 0;
      //     let b = yield a;
      //     yield b;
      //   }

      // const fun = mengmeng(1);
      // console.log(fun.next())
      // console.log(fun.next(1))
      // console.log(fun.next(2))

      //   const getRawType = (target) =>
      //     Object.prototype.toString.call(target).slice(8, -1);

      //   const __createArrayIterable = (arr) => {
      //     if (typeof Symbol !== 'function' || !Symbol.iterator) return {};
      //     if (getRawType(arr) !== 'Array') throw new Error('it must be Array');
      //     const iterable = {};
      //     iterable[Symbol.iterator] = () => {
      //       arr.length++;
      //       const iterator = {
      //         next: () => ({ value: arr.shift(), done: arr.length <= 0 }),
      //       };
      //       return iterator;
      //     };
      //     return iterable;
      //   };

      //   const itable = __createArrayIterable(['人月', '神话']);
      //   const it = itable[Symbol.iterator]();

      //   console.log(it.next()); // { value: "人月", done: false }
      //   console.log(it.next()); // { value: "神话", done: false }
      //   console.log(it.next()); // {value: undefined, done: true }
    </script> -->

  <!-- promise 原理 -->
  <!-- <script>
      const wanpan = new Promise((rev, rej) => {
        setTimeout(() => {
          if (Math.random() * 10 > 5) {
            rev(1);
          } else {
            rej(0);

            // 需要相应的catch 才能捕捉reject
            // Promise.reject(0).catch((err) => {
            //   debugger;
            //   console.log(err);
            // });
          }
        }, 1000);
      });

      wanpan
        .then((res) => {
          console.log(res);
        })
        .catch((err) => {
          console.log(err);
        });

      // setInterval(() => {
      //   console.log(wanpan);
      // }, 50);
    </script> -->

  <!-- JSON -->
  <!-- <script>
      // const obj = {
      //   wanpan: '11',
      // };
      // const str = encodeURIComponent(JSON.stringify(obj));
      // console.log('str-1', str);
      // console.log('str-2', decodeURIComponent(str));
      // console.log('str-3', JSON.parse(decodeURIComponent(str)));

      const str = encodeURIComponent(
        `taskId:1111-materialId:2222-H5Id:3333-originId:4444`,
      );

      const getStateParams = (strState) => {
        const obj = {};
        strState.split('-').forEach((el) => {
          const arr = el.split(':');
          obj[arr[0]] = arr[1];
        });
        return obj;
      };
      console.log(getStateParams(decodeURIComponent(str)));
    </script> -->

  <!-- this -->
  <!-- <script>
      var wanpan = 'c';
      var obj = {
        wanpan: 'b',
        getNmae: () => {
          return this.wanpan;
        },
      };

      console.log(obj.getNmae());
    </script> -->

  <!-- 闭包问题 -->
  <script>
    let obj = { name: 'wanpan' };

    function test() {
      console.log(obj.name);
    }

    setTimeout(test, 3000);
    obj.name = 111;
  </script>

  <!--  -->
</html>
