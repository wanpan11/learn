<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>

  <style>
    body,
    html {
      margin: 0;
      height: 100%;
    }
    .box {
      /* transform: translate(10px, 20px); */
      background-color: rgb(86, 168, 255);
      height: 100%;
      /* width: 20px;
      height: 20px; */
    }
  </style>

  <body>
    <div>
      <button>111</button>
    </div>

    <div class="box"></div>

    <button onmouseUp="btnClickHandler(event)">CLICK ME</button>
  </body>

  <!-- 类 原型链  -->
  <script type="text/javascript">
    // 1.0 类
    class Wanp {
      // 构造器
      constructor(a) {
        this.example = a;
      }

      // 实例方法 仅实例化对象才能访问 或从 Wanp.prototype.say() 访问
      say() {
        return '我是Wanpan的实例方法say';
      }
      hahaha() {}
      // 实例属性 仅实例化对象才能访问 原型Wanp 无法访问
      age = 25;
      like = 'car';
      height = '我是Wanp的实例属性！';
      arr = [1, 2, 3, 4, 5];

      // 静态方法 static 会生成私有属性 实例化对象无法访问
      static staticFuc() {
        return '我是Wanp的静态方法！';
      }
      static staticStr = '我是Wanp的静态属性！';
    }
    Wanp.type = 'person';
    Wanp.typeFun = function (params) {};
    console.log('#1-1 Wanp -', Wanp.prototype);

    const wanpan = new Wanp('hahaha');
    console.log('#2-1 wanpan -', wanpan);

    // 1.1 类的继承
    class Wanp_1 extends Wanp {
      constructor(a, b) {
        //当前类如果继承与其他类 且需要构造器时 需要使用super()先调用父级构造器方法
        super(a);
        this.sex = b;
      }
    }
    console.log('#3-1 Wanpan1 -', Wanp_1.prototype);
    console.log('#3-2 Wanpan1 -', Wanp_1.type);

    const wanpan_1 = new Wanp_1('papapa', 'lalala');
    console.log('#4-1 wanpan_1 -', wanpan_1);

    /* =============================================================================== */

    // 2.创建一个类(函数)
    function Tanxiufen(a, b) {
      //这里实际返回的 init的实例对象
      return new Tanxiufen.prototype.init(a, b);
    }
    Tanxiufen.prototype = {
      constructor: Tanxiufen,
      init: function (a, b) {
        this.name = a;
        this.age = b;
      },
      say: function () {
        return console.log(this.name + '今年' + this.age);
      },
      age: '888',
    };

    //因为 new Tanxiufen() 时间返回的是init的实例 所有需要把init的prototype 修改为Tanxiufen的prototype 从而拥有say()方法
    Tanxiufen.prototype.init.prototype = Tanxiufen.prototype;
    const tanxiufen = new Tanxiufen('谈秀芬', 24);

    // console.log(Tanxiufen.prototype);
    // console.log(tanxiufen.__proto__);
  </script>
  <!-- <script>
        function Person() {
            this.name;
        }
        Person.prototype.say = function () {
            console.log("hello");
        }

        var person = new Person();

        console.log(Person.__proto__);
        console.log(Function.prototype);

        console.log(Person.prototype.__proto__);
        console.log(Object.prototype);

        console.log(person.__proto__);
        console.log(Person.prototype);

        console.log(Person.prototype.constructor);
        console.log(Person);
    </script> -->

  <!-- 事件冒泡 -->
  <!-- <script>
        const btn = document.getElementsByTagName('button')[0]
        const div = document.getElementsByTagName('div')[0]
        btn.addEventListener('click', (e) => {
            console.log(e.target);
            e.stopImmediatePropagation()
            e.stopPropagation()
        })
        div.addEventListener('click', (e) => {
            console.log(e.target);
        })
        div.addEventListener('mouseup', (e) => {
            console.log(e.target);
        })

        document.addEventListener("mouseup", function (event) {
            console.log("document clicked");
        }, false);
    
        function btnClickHandler(event) {
            // event.stopPropagation(); 
            console.log("btn clicked");
        }

    </script> -->

  <!-- Object对象 -->
  <!-- <script>
      const o0 = new Object('宛攀');
      const o1 = new Object(111);
      console.log(o0, o1);

      const o2 = Object.prototype.toString.call('string');
      console.log(o2);
    </script> -->

  <!-- async await -->
  <!-- <script>
      /* 直接返回形式 */
      async function test_1(params) {
        /* reject */
        throw 1;
        /* resolve */
        // return params;
      }

      async function test(params) {
        // 赋值
        // const num = (await test_1(params)) + 2;

        // 链式
        await test_1(params)
          .then((feed) => {
            // console.log('#1', feed);
          })
          .catch((e) => {
            // console.log(e);
          });

        // console.log('#2', num);
      }

      /* 返回Promise 形式 */
      // async function test_1(params) {
      //   return new Promise((rev) => {
      //     setTimeout(() => {
      //       rev(params);
      //     }, 200);
      //   });
      // }

      // async function test(params) {
      //   // 赋值
      //   const num = (await test_1(params)) + 2;

      //   // 链式
      //   await test_1(params).then((feed) => {
      //     console.log('#1', feed);
      //   });

      //   console.log('#2', num);
      // }

      test(6);

      /* 
            Generator 函数
            Generator对象 像是一个方法集合 每个yield域 就是集合中的一个方法（子集们 被嵌套在一个公共方法里 所以每个子集都可以访问到其它子集的变量）
            每次调用next 方法就是执行下一个 yield域里的方法
        */
      //   function* mengmeng() {
      //     let a = yield 0;
      //     let b = yield a;
      //     yield b;
      //   }

      // const fun = mengmeng(1);
      // console.log(fun.next())
      // console.log(fun.next(1))
      // console.log(fun.next(2))

      //   const getRawType = (target) =>
      //     Object.prototype.toString.call(target).slice(8, -1);

      //   const __createArrayIterable = (arr) => {
      //     if (typeof Symbol !== 'function' || !Symbol.iterator) return {};
      //     if (getRawType(arr) !== 'Array') throw new Error('it must be Array');
      //     const iterable = {};
      //     iterable[Symbol.iterator] = () => {
      //       arr.length++;
      //       const iterator = {
      //         next: () => ({ value: arr.shift(), done: arr.length <= 0 }),
      //       };
      //       return iterator;
      //     };
      //     return iterable;
      //   };

      //   const itable = __createArrayIterable(['人月', '神话']);
      //   const it = itable[Symbol.iterator]();

      //   console.log(it.next()); // { value: "人月", done: false }
      //   console.log(it.next()); // { value: "神话", done: false }
      //   console.log(it.next()); // {value: undefined, done: true }
    </script> -->

  <!-- promise 原理 -->
  <!-- <script>
      const wanpan = new Promise((rev, rej) => {
        setTimeout(() => {
          if (Math.random() * 10 > 5) {
            rev(1);
          } else {
            rej(0);

            // 需要相应的catch 才能捕捉reject
            // Promise.reject(0).catch((err) => {
            //   debugger;
            //   console.log(err);
            // });
          }
        }, 1000);
      });

      wanpan
        .then((res) => {
          console.log(res);
        })
        .catch((err) => {
          console.log(err);
        });

      // setInterval(() => {
      //   console.log(wanpan);
      // }, 50);
    </script> -->

  <!-- JSON -->
  <!-- <script>
      // const obj = {
      //   wanpan: '11',
      // };
      // const str = encodeURIComponent(JSON.stringify(obj));
      // console.log('str-1', str);
      // console.log('str-2', decodeURIComponent(str));
      // console.log('str-3', JSON.parse(decodeURIComponent(str)));

      const str = encodeURIComponent(
        `taskId:1111-materialId:2222-H5Id:3333-originId:4444`,
      );

      const getStateParams = (strState) => {
        const obj = {};
        strState.split('-').forEach((el) => {
          const arr = el.split(':');
          obj[arr[0]] = arr[1];
        });
        return obj;
      };
      console.log(getStateParams(decodeURIComponent(str)));
    </script> -->

  <!-- this -->
  <!-- <script>
      var wanpan = 'c';
      var obj = {
        wanpan: 'b',
        getNmae: () => {
          return this.wanpan;
        },
      };

      console.log(obj.getNmae());
    </script> -->

  <!-- 闭包问题 -->
  <!-- <script>
    let obj = { name: 'wanpan' };

    function test() {
      console.log(obj.name);
    }

    setTimeout(test, 3000);
    obj.name = 111;
  </script> -->

  <!-- new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。 -->
  <!-- <script>
    // 函数表达式
    const wanpan = function () {
      console.log('函数表达式');
    };

    // 函数声明 具有变量提示
    function wanpan() {
      console.log('函数声明');
    }

    // 方法定义 方法没有构造函数
    const obj = {
      wanpan() {
        console.log('方法定义');
      },
    };

    ----- ES5 新写法 
    const obj_1 = {
      method() { // 但是这种新写法没有构造函数
        return 'Hello!';
      },
    };

    // 等同于 
    const obj_1 = {
      method: function (name) {
        this.name = name;
        return 'Hello!';
      },
    };

  ----- ES5 新写法 

    //例4 只有当类型为Normal的函数被创建时，它才是可构造的函数，否则他就是不可构造的。
    const example = {
      Fn: function () {
        console.log(this);
      }, // 函数 Normal
      Arrow: () => {
        console.log(this);
      }, // 箭头函数 Arrow
      Shorthand() {
        console.log(this);
      }, // 方法 Method
    };
    new example.Fn(); // Fn {}
    new example.Arrow(); // Uncaught TypeError: example.Arrow is not a constructor
    new example.Shorthand(); // Uncaught TypeError: example.Shorthand is not a constructor
  </script> -->
  <!-- 手写new -->
  <!-- <script>
    /* 接受一个构建函数 若干个参数 返回实例（或） */
    const my_new = function (constructor, ...args) {
      // 1、定义一个新对象
      const obj = {};

      // 2、获取构造函数的返回值
      const res = constructor.call(obj, ...args);

      // 3、将新对象的__proto__指向构造函数的prototype
      obj.__proto__ = constructor.prototype;

      // 4、判断构造函数的返回值 是否为对象 如果是则返此对象，反之返回新对象（实例）
      return res instanceof Object ? res : obj;
    };

    function Wanpan(name) {
      this.name = name;
      this.say = function () {
        console.log(this.name);
      };
      // return {};
    }

    // console.log(Wanpan.prototype);

    const wanpan = my_new(Wanpan, '宛攀');
    wanpan.say();
  </script> -->

  <!-- Symbol -->
  <!-- <script>
    window.onerror = (e) => {
      console.log('onerror', e);
    };

    const a = Symbol('foo');
    console.log(a);
    console.log(String(a));

    const obj = { name: 'wanpan' };

    obj.age.name;
  </script> -->

  <!-- 消息订阅 -->
  <!-- <script>
    // 发布订阅对象
    const eventEmitter = {};

    // 缓存列表，存放 event 及 fn
    eventEmitter.list = {};

    /* 订阅消息 */
    eventEmitter.on = function (event, fn) {
      const that = this;

      /* 如果订阅列表中 没有该事件就创建该事件并添加订阅回调 反之直接push新的回调函数*/
      if (!that.list[event]) {
        that.list[event] = [];
      }
      that.list[event].push(fn);

      return that;
    };

    /* 发布消息 */
    eventEmitter.emit = function () {
      const that = this;

      /* 获取事件名称 */
      const event = [].shift.call(arguments);
      /* 获取事件内 回调函数 */
      const fns = [...this.list[event]];

      if (!fns || fns.length < 1) {
        return false;
      } else {
        fns.forEach((fn) => {
          fn.call(that, arguments);
        });
      }
    };

    function user1(content) {
      console.log('用户1订阅了:', content);
    }

    function user2(content) {
      console.log('用户2订阅了:', content);
    }

    // 订阅
    eventEmitter.on('article', user1);
    eventEmitter.on('article', user2);

    // 发布
    eventEmitter.emit('article', 'Javascript 发布-订阅模式');

    console.log(eventEmitter);

    /*
    用户1订阅了: Javascript 发布-订阅模式
    用户2订阅了: Javascript 发布-订阅模式
    */
  </script> -->

  <!--  -->
</html>
